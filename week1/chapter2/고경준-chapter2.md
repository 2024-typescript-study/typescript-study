# 2장 타입

# 2.1 타입이란?

## 1. 자료형으로서의 타입

변수란 값을 저장할수 있는 공간이고 개발자는 변수를 선언하고 그 변수에 데이터를 할당한다.

```tsx
// Javascript 의 변수 선언
var name = "zig";
var year = 2022;

=> JS 엔진이 year에 할당된 값을 숫자로 인식해서 8byte 단위로 메모리 공간에 저장된 값을 읽어온다.
```

JS에서는 다음과 같은 7가지 데이터 타입(=자료형)을 변수에 저장할 수 있다.

- undefined, null, Boolean, String, Symbol, Numeric, Object

데이터타입은 여러 종류의 데이터를 식별하는 분류 체계로 컴파일러에 값의 형태를 알려준다.  

개발자는 타입을 사용해서 값의 종류를 명시할 수 있고 메모리를 더욱 효율적으로 사용할 수 있다.

## 2. 집합으로서의 타입

로그래밍에서의 타입은 수학의 집합과 유사하다. 타입은 값이 가질수 있는 유효한 범위의 집합을 말한다.

```tsx
const num: nuber = 123;
const str: string = "abc";

function func(n: number) {
	// ...
}

func(num);
func(str); // 🚨 에러
```

어떤 값이 T 타입이라면 컴파일러는 이 값으로 어떤 일을 할수 있고 어떤 일을 할수 없는지를 사전에 알 수 있다. 

타입 시스템은 사용되는 값의 범위를 제한해서 런타임에 발생할수 있는 유효하지 않은 값에 대한 에러를 방지한다.

```tsx
function double(n) {
	return n * 2;
}

double(2) // 4 => 예상했던 값의 type : number
double("z") // NaN => 예상하지 않은 값의 type : 
```

타입을 정의하지 않은 경우 ⇒ 실행되서 잘못된 결과

```tsx
function double(n : number) {
	return n * 2;
}

double(2) // 4
double("z") // 🚨 Type 에러 발생
```

타입을 정의한 경우 ⇒ 실행되지 않고 에러 방지

2의 타입은 number이기 때문에 컴파일단계에서 문제가 없지만  “z”는 string 타입은 컴파일에서 에러가 발생함.

⇒  타입스크립트 컴파일러는 함수를 호출할 때 호환되는 인자로 호출했는지로 판단한다.

## 3. 정적 타입과 동적 타입

JS에서는 변수의 값을 다룰때 타입을 고려하지 않고 코드를 쓸 수 있다.

JS도 분명히 타입이 존재하지만 개발자가 컴파일 이전에 타입을 직접 정의해줄 필요가 없을 뿐이다.

이렇게 타입을 결정하는 시점에 따라서 정적 타입과 동적 타입으로 분류할 수 있다.

### 정적 타입 시스템

- **정적 타입에서는 변수의 타입이 컴파일 타임에 결정된다.**
- 대표적인 정적 타입 언어 : C, Java, Typecsript 등..
- 코드수준에서 개발자가 직접 타입을 명시해주어야 한다.
- 컴파일에 에러를 발견할 수 있기 때문에 프로그램의 안정성을 보장 할 수있다.

### 동적 타입 시스템

- **동적 타입에서는 변수의 타입이 런타임에서 결정된다.**
- 대표적인 동적 타입 언어 : Python, Javascript
- 코드 수준에서 개발자가 직접 타입을 정의해줄 필요가 없다.

런타임에서 타입을 예측할수 없는 상황은 매우 위험한 상황이다. 다음의 예를 보자.

```tsx
function multiplyByThree(number) {
	return number * 3;
}

multiplyByThree(10); // 30 => 예상 했던 정수 형태의 결과값
multiplyByThree("f"); // NaN => number 타입이지만 예상하지 못한 결과
```

<aside>
✅

컴파일 타임과 런타임

개발자가 작성한 소스코드를 실행하려면 몇가지 과정을 거쳐야 하는데 시점에 따라서 컴파일 타임과 런타임으로 구분할 수 있다. 기계가 소스코드를 이해할수 있도록 기계어로 변환되는 시점을 컴파일타임이라고 하며, 이후 변환된 파일이 메모리에 적재되어 실행되는 시점을 런타임이라고한다.

- 컴파일 타임 : 소스코드가 기계어로 변환되는 시점
- 런 타임 :  변환된 파일이 메모리에 적재되어 실행되는 시점
</aside>

## 4. 강타입과 약타입

프로그래밍 언어에는 타입이 결정되는 시점은 다르지만  값의 타입이 존재한다.

자바스크립트는 동적 타입 언어라서 개발자가 타입을 명시해줄 필요가 없지만, 개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 컴파일러 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것을 암묵적 타입 변환이라고 한다.

암묵적 타입 변환 여부에 따라 타입시스템을 강타입과 약타입으로 분류할 수 있다.

- 강 타입 : 서로 다른 타입을 갖는 값끼리 연산할때는 시도하면 컴파일러 또는 인터프리터에서 에러 발생
- 약 타임 : 서로 다른 타입을 갖는 값끼리 연산할때는 컴파일러 또는 인터프리터가 내부적으로 판단해서 특정 값의 타입을 빼고 연산을 수행한 후 값을 도출한다.

<aside>
✅

더하기 연산자를 활용한 예시를 들지 않는 이유는 자바스크립트의  더하기 연산자는 문자열과 숫자타입을 모두 사용할 수 있기때문이다. 따라서 점진적 타입을 사용하는 타입스크립트는 역시 문법과 숫자타입간의 더하기 연산을 할 수 있디 때문에 강타입과 약타입을 분류하는 예시로 적절하지 않다.

</aside>

C++, Java, JS 에서는 서로 다른 타입을 갖는 값으로 빼기연산을 수행하면 정상적으로동작한다.  C++, Java 에서는 내부적으로 문자열 타입값을 숫자타입은 야스키 값으로 변경해서 연산한다. 또한 자바스크립트에서는 문자열로 표기된 숫자를 실제 숫자값으로 변환해서 빼기 연산을 한다. 

이에 반해 파이썬, 루비, 타입스크립트에서는 컴파일러 혹인 인터프리터에서 타입에러가 발생한다. 결론적으로 C++, 자바, 자바스크립트는 약타입언어로 파이썬 루비 타입스크립트는 강타입 언어로 분류할 수있다.

- 강타입 언어:  파이썬, 루비, 자바스크립트
- 약타입 언어 : C++, 자바, 자바스크립트

암묵적인 변환은 개발자가 명시적으로 타입을 변환하지 않아도 다른 데이터 타입끼리 연산을 진행할 수 있는 편리함을 제공하지만, 작성자의 의도와 다르게 동작할 수 있기 때문에 예기치 못한 오류가 발생할 가능성도 높아진다.예를 들어 자바스크립트는 타입이 명백하게 잘못 작성된 코드도 암묵적 타입을 수행해서 어떻게든 결과를 도출한다.

자바스크립트는 약타입 언어이기 때문에 런타임에서 발생할 수 있는 에러를 예측하고 방지하는 코드를 작성하는것이 프로그램을 안전하게 만드는데 도움이 된다. 여기서 안전한이란 표현은 타입안정성을 의미한다.

타입을 사용해서 프로그램이 유효하지 않은 작업을 수행하지 않도록 방지하는 것이다. 타입을 명시해서 코드를 작성한 후에는 프로그램 내에 기술된 개발자의 의도가 논리적으로 합당한지 검사하는 기준이 필요하다.

타입 검사기가 프로그램에 타입을 할당하는데 사용하는 규칙 집합을 타입 시스템이라고 한다. 타입시스템은 크게 두가지로 구분되는데 어떤 타입을 사용하는지를 컴파일러에 명시적으로 알려줘야 하는 타입시스템이 있고, 자동으로 타입을 추론하는 타입 시스템도 있다.

타입스크립트는 두가지 타입시스템의 영향을 모두 받았다. 즉 개발자는 직접 타입을 명시하거나 타입스크립트가 타입을 추론하도록 하는 방식중에서 선택할 수 있다. 

## 5. 컴파일 방식

컴파일이란 컴파일러가 사람이 작성한 코드를 컴퓨터가 이해할수 있는 기계어로 바꿔주는 과정이다.

즉 기본적으로 서로 다른 수준(고수준 - 저수준 )간의 코드 변환을 의미한다.

그러나 타입스크립트의 컴파일 결과물은 여전히 자바스크립트 파일이다.

타입스크립트가 탄생한 이유는 자바스크립트의 컴파일 타임에 런타임 에러를 사전에 잡아내기 위한것이다.

타입스크립트를 컴파일하면 타입이 모두 제거된 자바스크립트 소스코드만 남게된다.

이처럼 타입스크립트는 다른 타입의 개념을 사용하는 언어와는 구별되는 특징을 가지고 있다.

자바스크립트에 타입이라는 레이어를 끼얹은 일종의 템플릿 언어, 확장 언어로 해석하는 의견도 있다.

# 2.2 타입스크립트의 타입 시스템

## 1. 타입 애너테이션 방식 ⇒  `변수명 : {type 명}`

타입 에너테이션이란 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될것인지를 컴파일러에 직접 알려주는 문법이다. 언어마다 타입을 명시해주는 방법은 다르다.

자바와 C#에서는 변수앞에 데이터 타입을 명시해주지만 타입스크립트는 변수 이름 뒤에 타입을 명시해준다.

## 2. 구조적 타이핑

타입을 사용하는 여러 프로그래밍 언어에서 값이나 객체는 하나의 구체적인 타입을 가지고 있다. 

타입은 이름으로 구분되며 컴파일 타임 이후에도 남아있는데 이것을 명목적으로 구체화한 타입시스템이라 한다.

서로 다른 클래스끼리 상속관계이거나 공통으로 가지고 있는 인터페이스가 없다면 타입은 호환되지 않는다.

하지만 타입스크립트에서는 구조로 타입을 구분하는 구조적 타이핑 방식이다.

- 명목적인 타입언어 : Java ⇒ 타입을 이름으로 구분하고 컴파일 타임 이후에도 남아있는다. 호환 X
- 구조적인 타입언어 : 타입스크립트 ⇒ 타입을 구조로 구분한다. 호환 O

## 3. 구조적 서브타이핑

타입스크립트의 타입은 값의 집합으로 생각할 수 있다. 타입은 단지 집합에 포함되는 값이고 특정 값은 많은 집합에 포함될 수 있다. 따라서 타입스크립트에서는 여러개의 타입을 동시에 가질 수 있다. 

이렇게 집합으로 개념으로 나타낼수 있는 타입스크립트의 타입시스템의 기본 개념이 구조적 서브타이핑이다.

구조적 서브타이핑이란 객체가 가지고 있는 속성을 바탕으로 타입을 구분하는것이다. 이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.

**변수의 구조적 서브 타이핑**

```tsx
interface Pet {
	name: string;
}

interface Cat {
	name: string;
	age: number;
}

let pet: Pet;
let cat: Cat; = { name: "Zag", age: 2 };

pet = cat; // ✅
```

⇒ 타입의 이름이 다른데도 Pet이 가지고 있는 속성을 Cat도 가지고 있으니까

Cat 타입으로 선언한 변수를 Pet 타입에 선언한 변수에 할당할 수 있습니다.

**매개변수의 구조적 서브 타이핑**

```tsx
interface Pet {
	name: string;
}

let cat = { name: "Zag", age: 2 };

function greet(pet: Pet) {
	console.log("Hello, " + pet.name);
}

greet(cat);
```

⇒ 서로 다른 두 타입 간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다. 타입 A가 타입 B의 서브타입이라면 A타입의 인스턴스는 B 타입이 필요한 곳에 언제든지 위치할 수 있다. 즉, 타입의 계층 구조로 부터 자유롭다.

## 4. 자바스크립트를 닯은 타입스크립트

타입스크립트의 구조적 서브타이핑은 명목적 타이핑과 대조적인 타이핑 방식이다.

명목적 타이핑에서 두 변수는 같은 이름의 데이터 타입으로 선언된 경우에만 서로 호환된다.

타입을 이름으로 구분하기 때문에 구조가 같더라도 이름이 다르면 다른 타입으로 선언된다.

명목적 타이핑은 타입의 동일성을 확인하는 과정에서 구조적 타이핑에 비해 조금더 안전하다고 할수있다.

즉, 객체의 속성을 다른 객체의 속성과 호환되지 않도록 하여 안정성을 추구하기 때문인데

타입스크립트가 구조적 타이핑을 채택한 이유는 덕타이핑을 기반 자바스크립트를 모델링 한 언어이기 때문이다.

<aside>
✅

덕 타이핑이란?

 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는것으로 간주하는 방식이다.

“만약 어떤 새가 오리처럼 걷고 헤엄치며 꽥꽥 소리내면 그 새를 오리라고 한다.” 에서 유래됬다.

즉 함수의 매개변수값이 올바르게 주어진다면 그 값이 어떻게 만들어졋는지 신경쓰지 않고 사용한다.

</aside>

쉬운 사용성과 안정성이라는 두가지 목표 사이 균형을 중시하는 타입스크립트에서 이름으로 타입을 구분하는 대신 객체나 함수가 가진 구조적인 특징을 기반으로 타이핑하는 방식을 채탱했다 그래서 더 유연한 타이핑이 가능해졌고 객체간 속성이 동일하면 호환되는 구조적 타입 시스템을 제공해서 편리성을 높였다.

## 5. 구조적 타이핑의 결과

타입스크립트 구조적 타이핑의 특징 때문에 예기치 않은 결과가 나올수 있다.

```tsx
interface Cube {
	width: number;
	height: number;
	depth: number;
}

function addLines(c: Cube) {
	let total = 0;
	
	for (const axis of Object.keys(c)) {
		const length = c[axis];
		
		total += length;
	}
}

// 하지만 아래 변수에서 에러발생

const namedCube = {
	width: 6,
	height: 5,
	depth: 4,
	name: "SweetCube", // string 타입의 속성이 추가됬다.
}
```

⇒ namedCube는 Cube가 가지고 있는 속성을 모두 가지고 있으니까 Cube가 들어가야할곳에 할당할수있다.

하지만 addLines는 Cube의 모든 속성이 number라고 예측하기 때문에 에러가 발생할 수 있다.

## 6. 타입스크립트의 점진적 타입 확인

타입스크립트는 점진적으로 타입을 확인하는 언어이다. 점진적 타입검사란 ? 컴파일 타임에 타입을 검사하면서 필요에 따라 타입선언 생략을 허용하는 방식이다.

타입을 지정한 변수와 표현식은 정적으로 타입을 검사하지만 타입 선언이 생략되면 동적으로 검사를 수행한다. 타입 선언을 생략하면 암시적 타입 변환이 일어난다.

```tsx
function add(x, y) {
	return x + y;
}

// 위 코드는 아래와 같이 암시적 타입 변환이 일어난다.
function add(x: any, y: any): any;
```

타입스크립트에서는 필요에 따라 타입을 생략할 수도 있고 타입을 점진적으로 추가할수도 있다. 타입스크립트에서 프로그램을 컴파일하는데 반드시 모든 타입을 알야하는것은 아니다 그러나 컴파일 타입에 모든 타입을 알고있을때 최상의 결과를 보여준다.

타입스크립트는 자바스크립트의 슈퍼셋 언어이기 때문에 모든 자바스크립트 코드는 타입스크립트 코드라고 봐도 무방하다. 따라서 .ts 파일에 자바스크립트 코드를 작성해도 문제가 발생하지 않는다.

그래서 타입을 지정하지 않은 JS를 TS로 마이크레이션할때 이런 점진적 타이핑 특징을 유용하게 활용할수 있다.

그러나 이러한 특징때문에 타입시스템은 타임의 정확성을 100% 보장하지 않는다.

그래서 타입을 올바르게 정의하지 않으면 컴파일시엔 문제가 없지만 런타임시에 에러가 발생하기도 한다.

## 7. 자바스크립트 슈퍼셋으로서의 타입스크립트

타입스크립트는 기존 자바스크립트 코드에 정적인 타이핑을 추가한 것으로 자바스크립트의 상위집합이다.

선택적으로 타이핑을 도입할수 있는 자바스크립트의 특징때문에 타입스크립트는 자바스크립트가 가지고 있는 여러 문제를 가지고 있지만 이덕분에 타입스크립트의 진입장벽이 낮아졌다.

![image.png](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%201425dc2bbe6f80058cacd432739d9e9d/image.png)

모든 자바스크립트 코드는 타입스크립트라고 볼 수 있지만 반대로

모든 타입스크립트 코드가 자바스크립트 코드인것은 아니다.

```tsx
let developer = "Colin";
console.log(developer.toUppercase());

// 🚨 타입스크립트 컴파일러로 실행 결과
// Property "toUppercase" dose not exist on type "string".
// Did you mean "toUpperCase" ?

// 🚨 자바스크립트 실행시 런타임 에러
// developer.toUppercase is not a function
```

### 8. 값 VS 타입

### 9. 타입을 확인하는 방법

# 2.3 원시 타입

### 1. boolean ⇒ `truthy VS falsy`

### 2. undefined

### 3. null

```tsx
let value: null | undefined;
console.log(value); // undefined (값이 아직 할당되지 않음)

value = null;
console.log(value); // null
```

- null: 명시적, 의도적으로 값이 아직 비어있을 수 있음을 보여준다.
- undefined: 값이 할당 되지 않음

```jsx
console.log(null == undefined); // true
```

자바스크립트에서는 흔히 값이 없다는 것을 나타낼 때 위 둘을 혼용하고, 동등 연산자(==)로는 둘이 동일하다고 나온다  -> 항상 === 을 더 권장해서 써야하는 이유이다.

```tsx
type Person1 = {
  name: string;
  job?: string;
};

type Person2 = {
  name: string;
  job: string | null;
};
```

Person1에서는 job 속성 (직업)이 있을 수도 또는 없을 수도 있음을 나타냄.

Person2에서는 job이라는 속성을 사람마다 갖고 있지만 값이 비어있을 수도 있다는 것을 나타낸다. (무직인 상태)

### 4. number

자바스크립트의 숫자에 해당하는 모든 원시 값을 할당 가능하다.(+ NaN, Infinity ...)

### 5. bigInt

```tsx
const bigNumber1: bigInt = BigInt(999999999999);
const bigNumber1: bigInt = 999999999999n;
```

ES2020에서 새롭게 도입된 데이터 타입으로 타입스크립트 3.2 버전부터 사용 가능.

- 자바스크립트에서는 가장 큰 수 Number.MAX_SAFE_INTEGER(2**53-1)를 넘어가는 값을 처리할 수 없었는데 bigInt를 사용하면 이보다 큰 수를 처리할 수 있다.
- number과 bigInt는 엄연히 서로 다른 타입이기 때문에 상호 작용은 불가능.

### 6. string

문자열. 공백도 해당. ``(백틱)으로 감싼 문자열 내부에 변숫값 포함 -> 템플릿 리터럴 문법

### 7. symbol

```tsx
const MOVIE_TITLE = Symbol("title");
const MUSIC_TITLE = Symbol("title");

console.log(MOVIE_TITLE === MUSIC_TITLE); // false

let SYMBOL: unique symbol = Symbol(); // A variable whose type is a 'unique symbol' type must be 'const'
```

ES2015에서 도입된 데이터 타입으로 Symbol() 함수를 사용하면 어떤 값과도 중복되지 않는 유일한 값을 생성할 수 있다. 타입스크립트에서는 symbol 타입과 const 선언에서만 사용할 수 있는 unique symbol 타입이라는 symbol의 하위 타입도 있다.

> ts-config의 strictNullChecks 옵션을 활성화했을 때는 사용자가 명시적으로 해당 타입에 null이나 undefined를 포함해야만 null과 undefined를 사용할 수 있다.
> 
> 
> 그렇지 않으면 null, undefined가 될 수 있는 경우에 타입스크립트 에러가 발생하는데 보통 **타입 가드(권장)**로 null, undefined가 되는 경우를 걸러낸다.
> 

---

# 2.4 객체 타입

앞에서 언급한 7가지 원시 타입에 속하지 않는 값은 모두 객체 타입으로 분류할 수 있다.

타입스크립트에서는 다양한 형태를 가지는 객체마다 개별적으로 타입을 지정할 수 있다.

## 1. object

가급적 사용 권장하지 않고 잘쓰이지 않는다. any 타입과 유사하게 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색된다.

```tsx
function isObject(value: object) {
    return (
        Object.prototype.toString.call(value).replace(\/[|\]|\s|object/g, "") === "Object"
    );
}

// 객체, 배열, 정규 표현식, 함수, 클래스 등 모두 object 타입과 호환됨
isObject({});
isObject({name: "KG"});
isObject([0, 1, 2]);
isObject(new RegExp("object"));
isObject(function () {
    console.log("hello world");
});

// 그러나 원시타입은 호환되지 않는다.
isObject(20); // false
isObject("KG"); // false
```

### 2. {}

중괄호는 자바스크립트에서 객체 리터럴 방식으로 객체를 생성할 때 사용한다. 

타입스크립트에서는 중괄호 안에 객체의 속성 타입을 지정해주는 식으로 사용한다.

**⇒ 타이핑되는 객체가 중괄호 안에서 선언된 구조와 일치해야 한다.**

```tsx
const noticePopup: {title: string; description: string} = {
    title: 'IE 지원 종료 안내', // string 타입
    description: '2022.07.15일부로 배민상회 IE 브라우저 지원을 종료합니다.'; // string 타입
}
```

자바스크립트에서 빈객체를 생성할때 `const obj = {};`  를 사용할수 있지만

타입스크립트에서는 {}로 명시하면 빈 객체임을 의미해 어떤 값도 속성으로 할당할 수 없다.

⇒ 빈 객체 타입 지정을 위해서는 유틸리티 타입으로 Record<string, never>처럼 사용하는게 바람직하다.

{} 타입으로 지정된 객체는 완전히 비어있는 순수한 객체를 의미하는 것이 아니다.

자바스크립트 프로토타입 체이닝으로 Object 객체 래퍼에서 제공하는 속성에는 정상적으로 접근할 수 있다.

### 3. array

자바스크립트에서는 하나의 배열 안에 여러 타입 값이 혼재될 수 있지만 타입스크립트에서는 배열을 array라는 별도 타입으로 다루고 배열 타입은 하나의 타입 값만 가질 수 있다.

Array 키워드로 선언하거나 대괄호([])를 사용해 선언한다 -> 팀 컨벤션에 맞게 사용

```tsx
const getCartList = async (cartId: number[]) => {
  const res = await CartApi.GET_CART_LIST(cartId);
  return res.getData();
};

getCartList([]); // 빈 배열도 가능
getCartList([1001]);
getCartList([1001, 1002, 1003]); // 타입 원소 몇 개가 들어와도 상관 x
getCartList([1001, "1002"]); // (X)
```

튜플 타입도 대괄호로 선언되므로 주의해야한다. 튜플의 대괄호 내부에는 선언 시점에 지정해준 타입 값만 할당 가능하고 원소 개수도 타입 선언 시점에 미리 정해진다.

객체 리터럴에서 선언하지 않은 속성을 할당하거나, 선언한 속성을 할당하지 않을 때 에러가 발생하는 점과 비슷하다.

### 4. type과 interface 키워드

object 타입은 실무에서 사용 잘사용되지 않는다. 객체를 타이핑하기 위해서는 타입스크립트에서만 독자적으로 사용할 수 있는 키워드를 사용하는게 일반적이고 중괄호를 사용한 객체 리터럴 방식으로 타입을 매번 일일이 지정하기에는 중복적인 요소가 많다.

```tsx
type NoticePopupType = {
    title: string;
    description: string;
}

const noticePopup1: NoticePopupType = {...};
```

타입스크립트 컴파일러가 변수 사용 방식과 할당된 값의 타입을 분석해서 타입을 유추한다.

- 타입 추론은 개인의 취향 또는 팀 컨벤션에 따라 다를 수 있다.

### 5. function

매개변수와 반환 값에 대한 타입을 지정

```tsx
function add(a: number, b: number): number {
  return a + b;
}
```

함수 자체의 타입 지정 -> 호출 시그니처를 정의

<aside>
✅

호출 시그니처(Call Signature)란?

타입스크립트에서 함수 타입을 정의할 때 사용하는 문법.

함수 타입은 해당 함수가 받는 매개변수와 반환하는 값의 타입으로 결정된다.

호출 시그니처는 이러한 함수의 매개변수와 반환 값의 타입을 명시하는 역할을 한다.

</aside>

```tsx
type AddFunction = (a: number, b: number) => number;
```

타입스크립트에서 함수 자체의 타입을 명시할 때는 화살표 함수 방식으로만 호출 시그니처를 정의한다.

```tsx
const add: AddFunction = (a, b) => {
  return a + b;
};
```